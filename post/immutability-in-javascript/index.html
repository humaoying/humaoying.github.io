<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Immutability in JavaScript - Farmer</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Farmer"><meta name=description content=" 原文：Immutability in JavaScript
根据维基百科，不可变对象（不可更改对象）是创​​建后状态无法修改的对象。该规则非常简单，如果要修改对象的某些属性，则必须在副本上进行操作。稍后我们将看到它为我们的开发带来了哪些改进和精美功能。
"><meta name=keywords content="blog,farmer"><meta name=generator content="Hugo 0.104.3 with theme even"><link rel=canonical href=https://humaoying.github.io/post/immutability-in-javascript/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.2da23a641a79c84e86a32fd0a7c6a15411d244b144e7470bd8e115b6fcfa3711.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Immutability in JavaScript"><meta property="og:description" content="
原文：Immutability in JavaScript

根据维基百科，不可变对象（不可更改对象）是创​​建后状态无法修改的对象。该规则非常简单，如果要修改对象的某些属性，则必须在副本上进行操作。稍后我们将看到它为我们的开发带来了哪些改进和精美功能。"><meta property="og:type" content="article"><meta property="og:url" content="https://humaoying.github.io/post/immutability-in-javascript/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-03-28T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-28T00:00:00+00:00"><meta itemprop=name content="Immutability in JavaScript"><meta itemprop=description content="
原文：Immutability in JavaScript

根据维基百科，不可变对象（不可更改对象）是创​​建后状态无法修改的对象。该规则非常简单，如果要修改对象的某些属性，则必须在副本上进行操作。稍后我们将看到它为我们的开发带来了哪些改进和精美功能。"><meta itemprop=datePublished content="2020-03-28T00:00:00+00:00"><meta itemprop=dateModified content="2020-03-28T00:00:00+00:00"><meta itemprop=wordCount content="1879"><meta itemprop=keywords content="JavaScript,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Immutability in JavaScript"><meta name=twitter:description content="
原文：Immutability in JavaScript

根据维基百科，不可变对象（不可更改对象）是创​​建后状态无法修改的对象。该规则非常简单，如果要修改对象的某些属性，则必须在副本上进行操作。稍后我们将看到它为我们的开发带来了哪些改进和精美功能。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Farmer</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Farmer</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Immutability in JavaScript</h1><div class=post-meta><span class=post-time>2020-03-28</span><div class=post-category><a href=/categories/%E7%BF%BB%E8%AF%91/>翻译</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#ecmascript>EcmaScript</a><ul><li><a href=#objectassign>Object.assign</a></li><li><a href=#arrayconcat>Array.concat</a></li><li><a href=#objectfreeze>Object.freeze</a></li><li><a href=#spread-operator>Spread operator</a></li></ul></li><li><a href=#为什么要使用不变性>为什么要使用不变性？</a><ul><li><a href=#好处是什么>好处是什么？</a></li><li><a href=#被现代框架库重视>被现代框架/库重视</a></li><li><a href=#为什么我们需要实用程序库>为什么我们需要实用程序库？</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><blockquote><p>原文：<a href=https://yvonnickfrin.dev/immutability-in-javascript>Immutability in JavaScript</a></p></blockquote><p>根据维基百科，不可变对象（不可更改对象）是创​​建后状态无法修改的对象。该规则非常简单，如果要修改对象的某些属性，则必须在副本上进行操作。稍后我们将看到它为我们的开发带来了哪些改进和精美功能。</p><h2 id=ecmascript>EcmaScript</h2><p>EcmaScript 提供了实用程序来使我们的数据保持不变。数组和对象 API 包含创建副本，甚至阻止实例更新的方法。最近，EcmaScript 引入了一些新的语法来创建对象和数组的副本。</p><h3 id=objectassign>Object.assign</h3><p>我们想在对象中添加一个name属性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>lutraLutra</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>commonNames</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;eurasian otter&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们可以使用 <code>Object.assign</code> 和一些技巧来做到这一点。基本上，它将所有属性从一个对象复制到另一个对象，从而使目标对象发生改变。我们使用一个小技巧，将一个空对象作为第一个参数，这将创建一个新引用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newLutraLutra</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>assign</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>{},</span> 
</span></span><span class=line><span class=cl>  <span class=nx>lutraLutra</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Lutra lutra&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>现在，我们有了一个具有新 <code>name</code> 属性的新对象，并且 <code>commonNames</code> 属性保持不变。使用此方法，您可以同时创建/覆盖多个属性。</p><h3 id=arrayconcat>Array.concat</h3><p>现在，让我们用数组来做。我们希望以不变的方式在数组中添加两个新元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>commonNames</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;eurasian otter&#39;</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>与 <code>Array.push</code> 不同，<code>Array.concat</code> 不会使我们的数组发生改变。而是返回一个新数组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newCommonNames</span> <span class=o>=</span> <span class=nx>commonNames</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;european otter&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;common otter&#39;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这种方法很灵活。它可以接受一个或多个元素。它们可以是值或数组。</p><h3 id=objectfreeze>Object.freeze</h3><p><code>Object.freeze</code> 并不是很熟悉。它使对象不可变！它可以防止各种类型的改变（创建，修饰，删除）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>lutraLutra</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>commonNames</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;eurasian otter&#39;</span><span class=p>,</span> <span class=s1>&#39;european otter&#39;</span><span class=p>,</span> <span class=s1>&#39;common otter&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Lutra lutra&#39;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>冻结对象后，我们将尝试删除 <code>name</code> 属性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>lutraLutra</span> <span class=o>=</span> <span class=nb>Object</span><span class=p>.</span><span class=nx>freeze</span><span class=p>(</span><span class=nx>lutraLutra</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=nx>lutraLutra</span><span class=p>.</span><span class=nx>name</span>
</span></span></code></pre></td></tr></table></div></div><p>使用 <code>Object.freeze</code> 使作为参数传递的对象不可变。此方法有两种可用模式：</p><ul><li>非严格模式下，改变没效果</li><li>严格模式下，如果您尝试修改，则会引发 TypeError</li></ul><p><strong>注意，它不是递归的。我们的属性 <code>commonNames</code> 不是不可改变的。</strong></p><h3 id=spread-operator>Spread operator</h3><p>ES2015 在数组中引入了扩展运算符语法，ES2018 也在对象中引入。它将给定对象的所有属性复制到新的对象文字中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newLutraLutra</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span><span class=nx>lutraLutra</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Lutra lutra&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>使用数组时，它将数组的所有值复制到新数组中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newCommonNames</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span><span class=nx>commonNames</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;common otter&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>它很好地替换了 <code>assign</code> 和 <code>concat</code>，易于阅读。</p><h2 id=为什么要使用不变性>为什么要使用不变性？</h2><p>你了解了如何使用 JavaScript 使对象和数组不可变，但是我们至今仍未解释为什么为什么必须使用不可变性。作为开发人员，我们一直在寻找编写更可维护和可读的代码的方法。一些诸如函数式编程之类的范例正专注于此。</p><blockquote><p>函数式编程的目标是使我们减少思考，编写更多描述性代码。</p><p>-<a href=https://hackernoon.com/functional-programming-paradigms-in-modern-javascript-immutability-4e9751ca005c>Alexander Kondov</a></p></blockquote><p>它具有声明式的编程方法，这意味着您将重点放在描述程序必须完成的事情上，而不是程序应该如何完成。它为您的代码赋予了更多含义，以便下一个开发人员可以更轻松地理解它。函数式编程带来了其他有助于实现此目标的概念，例如不变性。</p><h3 id=好处是什么>好处是什么？</h3><p>这听起来像是炒作术语吗？不可变性为我们每天遇到的编程问题带来了许多解决方案：</p><ul><li>避免副作用</li><li>数据更改检测变得简单（浅比较）</li><li>显式数据更改</li><li>记忆化</li><li>内存优化</li><li>更好的渲染性能</li><li>易于测试</li></ul><blockquote><p>与 JavaScript 世界中的大多数趋势不同，数据不变性必然会在一段时间内停留在我们身上，这有充分的理由：首先，因为这不是趋势，这是一种编码（和思考代码）的方式，可以提高清晰度，简化操作使用和理解数据流，并使代码不易出错。</p><p>-<a href=https://hackernoon.com/data-immutability-with-vanilla-javascript-63834a65a6c9>Ricardo Magalhães</a></p></blockquote><p>在过去的几年中，我们最大的挑战之一是找到一种有效的方法来检测数据中的变化，以确定是否应该渲染接口。检测原始值之间的变化很容易，但是对于对象和数组则完全不同。您可以按值比较它们，但必须实施递归算法并处理诸如循环引用之类的潜在问题。另一种方法是将对象引用与严格相等运算符===进行比较。它更有效，并且没有进入任何致命的无限循环的风险。因此，现代框架实施了这一概念。</p><h3 id=被现代框架库重视>被现代框架/库重视</h3><p>现代的前端框架和库基于可大大提高性能的概念。这是众所周知的虚拟 DOM。该技术是根据简单的证据创建的：DOM 操作很昂贵。</p><p>如前所述，前端框架和库选择使用不变性以提高其性能。如今，我们必须在应用程序中处理越来越多的数据，因此需要处理更多的标记。因此，我们的浏览器需要比10年前处理更多的计算。DOM 操作很昂贵，现代框架倾向于减少 DOM 更新的数量。</p><h3 id=为什么我们需要实用程序库>为什么我们需要实用程序库？</h3><p>正如我们前面所看到的，由于使用了语法糖，因此在 <code>EcmaScript</code> 中处理不变性的方法很简单，但是在嵌套结构中却非常有限。随着像 <code>redux</code> 这样的库的出现，嵌套结构变得越来越流行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>animals</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>weasels</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>lutraLutra</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>commonNames</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;eurasian otter&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newAnimals</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span><span class=nx>animals</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>weasels</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span><span class=nx>animals</span><span class=p>.</span><span class=nx>weasels</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>lutraLutra</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span><span class=nx>animals</span><span class=p>.</span><span class=nx>weasels</span><span class=p>.</span><span class=nx>otter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Lutra lutra&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如您所见，编写变得更加乏味且难以阅读。简单的用例（如覆盖数组的索引）很难实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>lutraLutra</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Lutra lutra&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>commonNames</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;eurasian otter&#39;</span><span class=p>,</span> <span class=s1>&#39;european&#39;</span><span class=p>,</span> <span class=s1>&#39;common otter&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newCommonNames</span> <span class=o>=</span> <span class=p>[...</span><span class=nx>lutraLutra</span><span class=p>.</span><span class=nx>commonNames</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nx>newCommonNames</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;european otter&#39;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>newLutraLutra</span> <span class=o>=</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=p>...</span><span class=nx>lutraLutra</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>commonNames</span><span class=o>:</span> <span class=nx>newCommonNames</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这些原因足以开始寻找一些工具，帮助您专注于真正重要的事情，即代码的含义。这就是我们创建 <code>immutadot</code> 的原因，以帮助我们保持 <code>javascript</code> 代码库的可读性和可维护性。<a href=https://github.com/zenika-open-source/immutadot>试试看</a>。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/javascript/>JavaScript</a></div><nav class=post-nav><a class=prev href=/post/hello-hugo/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Hugo 建站记录</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/use-closure-deeply/><span class="next-text nav-default">闭包在 curry/compose/memo 中的使用</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=humaoying/humaoying.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://github.com/piaoyidage class="iconfont icon-github" title=github></a>
<a href=https://humaoying.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2021 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>Farmer</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>